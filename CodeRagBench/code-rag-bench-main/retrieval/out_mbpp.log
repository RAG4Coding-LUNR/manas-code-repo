nohup: ignoring input
INFO 07-23 21:12:50 [__init__.py:244] Automatically detected platform cuda.
2025-07-23 21:12:53 - Use pytorch device_name: cuda:0
2025-07-23 21:12:53 - Load pretrained SentenceTransformer: codesage/codesage-base-v2
2025-07-23 21:13:02 - Query prompt: None, Passage prompt: None
2025-07-23 21:13:02 - Query prompt name: None, Passage prompt name: None
2025-07-23 21:13:02 - Loading Corpus...
  0%|          | 0/964 [00:00<?, ?it/s]100%|██████████| 964/964 [00:00<00:00, 293354.79it/s]
2025-07-23 21:13:02 - Loaded 964 TEST Documents.
2025-07-23 21:13:02 - Doc Example: {'text': '# Write a function to find the longest chain which can be formed from the given set of pairs.\nclass Pair(object): \r\n\tdef __init__(self, a, b): \r\n\t\tself.a = a \r\n\t\tself.b = b \r\ndef max_chain_length(arr, n): \r\n\tmax = 0\r\n\tmcl = [1 for i in range(n)] \r\n\tfor i in range(1, n): \r\n\t\tfor j in range(0, i): \r\n\t\t\tif (arr[i].a > arr[j].b and\r\n\t\t\t\tmcl[i] < mcl[j] + 1): \r\n\t\t\t\tmcl[i] = mcl[j] + 1\r\n\tfor i in range(n): \r\n\t\tif (max < mcl[i]): \r\n\t\t\tmax = mcl[i] \r\n\treturn max', 'title': '__init__'}
2025-07-23 21:13:02 - Loading Queries...
2025-07-23 21:13:02 - Loaded 500 TEST Queries.
2025-07-23 21:13:02 - Query Example: Write a python function to remove first and last occurrence of a given character from the string.
2025-07-23 21:13:02 - Encoding Queries...
Batches:   0%|          | 0/8 [00:00<?, ?it/s]Batches:  12%|█▎        | 1/8 [00:00<00:04,  1.58it/s]Batches:  50%|█████     | 4/8 [00:00<00:00,  6.08it/s]Batches:  75%|███████▌  | 6/8 [00:00<00:00,  8.42it/s]Batches: 100%|██████████| 8/8 [00:01<00:00, 10.07it/s]Batches: 100%|██████████| 8/8 [00:01<00:00,  7.59it/s]
2025-07-23 21:13:03 - Sorting Corpus by document length (Longest first)...
2025-07-23 21:13:03 - Encoding Corpus in batches... Warning: This might take a while!
2025-07-23 21:13:03 - Scoring Function: Dot Product (dot)
2025-07-23 21:13:03 - Encoding Batch 1/1...
Batches:   0%|          | 0/16 [00:00<?, ?it/s]Batches:  12%|█▎        | 2/16 [00:01<00:09,  1.53it/s]Batches:  19%|█▉        | 3/16 [00:01<00:08,  1.61it/s]Batches:  25%|██▌       | 4/16 [00:02<00:06,  1.78it/s]Batches:  31%|███▏      | 5/16 [00:02<00:05,  1.97it/s]Batches:  38%|███▊      | 6/16 [00:03<00:04,  2.18it/s]Batches:  44%|████▍     | 7/16 [00:03<00:03,  2.35it/s]Batches:  50%|█████     | 8/16 [00:03<00:03,  2.62it/s]Batches:  56%|█████▋    | 9/16 [00:04<00:02,  2.86it/s]Batches:  62%|██████▎   | 10/16 [00:04<00:01,  3.05it/s]Batches:  69%|██████▉   | 11/16 [00:04<00:01,  3.21it/s]Batches:  75%|███████▌  | 12/16 [00:04<00:01,  3.46it/s]Batches:  81%|████████▏ | 13/16 [00:05<00:00,  3.81it/s]Batches:  88%|████████▊ | 14/16 [00:05<00:00,  4.27it/s]Batches:  94%|█████████▍| 15/16 [00:05<00:00,  4.70it/s]Batches: 100%|██████████| 16/16 [00:05<00:00,  5.22it/s]Batches: 100%|██████████| 16/16 [00:05<00:00,  2.91it/s]
Time taken to retrieve: 6.95 seconds
Creating json from Arrow format:   0%|          | 0/1 [00:00<?, ?ba/s]Creating json from Arrow format: 100%|██████████| 1/1 [00:00<00:00, 12.49ba/s]
2025-07-23 21:13:10 - Retriever evaluation for k in: [1, 3, 5, 10, 100, 1000]
2025-07-23 21:13:10 - For evaluation, we ignore identical query and document ids (default), please explicitly set ``ignore_identical_ids=False`` to ignore this.
2025-07-23 21:13:11 - 

2025-07-23 21:13:11 - NDCG@1: 0.8920
2025-07-23 21:13:11 - NDCG@3: 0.9467
2025-07-23 21:13:11 - NDCG@5: 0.9510
2025-07-23 21:13:11 - NDCG@10: 0.9523
2025-07-23 21:13:11 - NDCG@100: 0.9537
2025-07-23 21:13:11 - NDCG@1000: 0.9537
2025-07-23 21:13:11 - 

2025-07-23 21:13:11 - MAP@1: 0.8920
2025-07-23 21:13:11 - MAP@3: 0.9350
2025-07-23 21:13:11 - MAP@5: 0.9374
2025-07-23 21:13:11 - MAP@10: 0.9380
2025-07-23 21:13:11 - MAP@100: 0.9383
2025-07-23 21:13:11 - MAP@1000: 0.9383
2025-07-23 21:13:11 - 

2025-07-23 21:13:11 - Recall@1: 0.8920
2025-07-23 21:13:11 - Recall@3: 0.9800
2025-07-23 21:13:11 - Recall@5: 0.9900
2025-07-23 21:13:11 - Recall@10: 0.9940
2025-07-23 21:13:11 - Recall@100: 1.0000
2025-07-23 21:13:11 - Recall@1000: 1.0000
2025-07-23 21:13:11 - 

2025-07-23 21:13:11 - P@1: 0.8920
2025-07-23 21:13:11 - P@3: 0.3267
2025-07-23 21:13:11 - P@5: 0.1980
2025-07-23 21:13:11 - P@10: 0.0994
2025-07-23 21:13:11 - P@100: 0.0100
2025-07-23 21:13:11 - P@1000: 0.0010
2025-07-23 21:13:11 - 

2025-07-23 21:13:11 - MRR@1: 0.8940
2025-07-23 21:13:11 - MRR@3: 0.9360
2025-07-23 21:13:11 - MRR@5: 0.9384
2025-07-23 21:13:11 - MRR@10: 0.9390
2025-07-23 21:13:11 - MRR@100: 0.9393
2025-07-23 21:13:11 - MRR@1000: 0.9393
2025-07-23 21:13:11 - 

2025-07-23 21:13:11 - R_cap@1: 0.8940
2025-07-23 21:13:11 - R_cap@3: 0.9800
2025-07-23 21:13:11 - R_cap@5: 0.9900
2025-07-23 21:13:11 - R_cap@10: 0.9940
2025-07-23 21:13:11 - R_cap@100: 1.0000
2025-07-23 21:13:11 - R_cap@1000: 1.0000
2025-07-23 21:13:11 - 

2025-07-23 21:13:11 - Hole@1: 0.0560
2025-07-23 21:13:11 - Hole@3: 0.3247
2025-07-23 21:13:11 - Hole@5: 0.3844
2025-07-23 21:13:11 - Hole@10: 0.4232
2025-07-23 21:13:11 - Hole@100: 0.4730
2025-07-23 21:13:11 - Hole@1000: 0.4640
2025-07-23 21:13:11 - Query : Write a function to find whether all the given tuples have equal length or not.

2025-07-23 21:13:11 - Rank 1: 70_code [find_equal_tuple] - # Write a function to find whether all the given tuples have equal length or not.
def find_equal_tuple(Input, k):
  flag = 1
  for tuple in Input:
    if len(tuple) != k:
      flag = 0
      break
  return flag
def get_equal(Input, k):
  if find_equal_tuple(Input, k) == 1:
    return ("All tuples have same length")
  else:
    return ("All tuples do not have same length")

2025-07-23 21:13:11 - Rank 2: 222_code [check_type] - # Write a function to check if all the elements in tuple have same data type or not.
def check_type(test_tuple):
  res = True
  for ele in test_tuple:
    if not isinstance(ele, type(test_tuple[0])):
      res = False
      break
  return (res) 

2025-07-23 21:13:11 - Rank 3: 651_code [check_subset] - # Write a function to check if one tuple is a subset of another tuple.
def check_subset(test_tup1, test_tup2):
  res = set(test_tup2).issubset(test_tup1)
  return (res) 

